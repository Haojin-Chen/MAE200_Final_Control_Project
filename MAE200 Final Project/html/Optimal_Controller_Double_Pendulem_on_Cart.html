
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Optimal_Controller_Double_Pendulem_on_Cart</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-03-25"><meta name="DC.source" content="Optimal_Controller_Double_Pendulem_on_Cart.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Determine u_k and state</a></li><li><a href="#3">Uncomment the Following Code if you need an x_k and u_k using Adjoint method to generate swingup states trajectory</a></li><li><a href="#4">If Previous Trajectory has been generated, run this code</a></li><li><a href="#5">Find A(t), E(t), B(t) for Each x_k in the swing up phase</a></li><li><a href="#6">Compute K(t) using A(t), E(t), B(t), C(t)</a></li><li><a href="#7">Compute L(t) using A(t), E(t), B(t), C(t)</a></li><li><a href="#8">Uncomment this section to check eigenvalues of the control + observation system</a></li><li><a href="#9">Plot State Trajectory using K(t) Controller</a></li><li><a href="#10">Add Estimation Technique to system using L(t)</a></li><li><a href="#11">Part LTI Component of Control Problem</a></li><li><a href="#12">Solve for LTI Controller Gain K and Observer Gain L</a></li><li><a href="#13">March States Starting from time T on the Estimated Simulated LQR States using RK4</a></li><li><a href="#14">March States Starting from time T on the Estimated LQG States using RK4</a></li></ul></div><pre class="codeinput"><span class="comment">%{
</span><span class="comment">The following code is used to design an optimal controller and estimator for 2 pendulem of
</span><span class="comment">different length and mass on a single cart. The only acutator on this car
</span><span class="comment">the motor that drives the linear position of the cart.
</span><span class="comment">
</span><span class="comment">We are attempting to swing up both the pendulem from the inital position of
</span><span class="comment">all pendulem down to both pendulem up and stabilize
</span><span class="comment">
</span><span class="comment">%}</span>
</pre><h2 id="2">Determine u_k and state</h2><pre class="codeinput">clear <span class="string">all</span>; clc; close <span class="string">all</span>
load_prev = 1; <span class="comment">%set to 1 if a previous trajectory has been generated</span>

<span class="comment">%{
</span><span class="comment">Use code provided in NR Ch21 to generate x_k state, u_k, using adjoint
</span><span class="comment">method for the swing up phase. This phase last about T = 3 seconds because
</span><span class="comment">
</span><span class="comment">0) Within this code, tune QT to drive error at T close to zero
</span><span class="comment">1) Warm start: use an inital guess of u_k being all zeros
</span><span class="comment">2) iterate the provided function with a new u_k until the state reach near
</span><span class="comment">desired value of [0 0 0 0 0 0]
</span><span class="comment">3)save x_k and u_k
</span><span class="comment">
</span><span class="comment">%}</span>
</pre><h2 id="3">Uncomment the Following Code if you need an x_k and u_k using Adjoint method to generate swingup states trajectory</h2><pre class="codeinput"><span class="comment">% T = 3; %approx sqrt(g/l)</span>
<span class="comment">%</span>
<span class="comment">% %initial guess of u_k being all zero</span>
<span class="comment">% [u_k(:,1),x_k] = OptimizeTraj(T);</span>
<span class="comment">%</span>
<span class="comment">% state_at_T(:,1) = x_k(1:6, end);</span>
<span class="comment">%</span>
<span class="comment">% number_of_trial = 1;</span>
<span class="comment">% trial_number = 1:number_of_trial</span>
<span class="comment">% for i = trial_number</span>
<span class="comment">%     [u_k(:,i+1), x_k] = OptimizeTraj(T, u_k(:,i))</span>
<span class="comment">%     state_at_T(:,i+1) = x_k(1:6, end)</span>
<span class="comment">% end</span>
</pre><h2 id="4">If Previous Trajectory has been generated, run this code</h2><pre class="codeinput"><span class="comment">%Trjectory can be manually optimzed by tuning Q iteration by interation by</span>
<span class="comment">%using the file "AdjointPathManualIteration.m"</span>

<span class="comment">%load previous trajectory is better</span>

<span class="keyword">if</span> load_prev == 1
    clear <span class="string">all</span>; clc;
    load(<span class="string">"SavePoint3.mat"</span>)
    figure(1); clf; subplot(3,1,1); plot(t,x_k(1,:),<span class="string">'r-'</span>,t,x_k(2,:),<span class="string">'b-'</span>,t,x_k(3,:),<span class="string">'g-'</span>); hold <span class="string">on</span>; title(<span class="string">"Openloop State"</span>);
              subplot(3,1,2); plot(t,x_k(4,:),<span class="string">'r-'</span>,t,x_k(5,:),<span class="string">'b-'</span>,t,x_k(6,:),<span class="string">'g-'</span>); hold <span class="string">on</span>;
              subplot(3,1,3); plot(t,u_k,<span class="string">'r--'</span>); hold <span class="string">on</span>;

<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_01.png" alt=""> <h2 id="5">Find A(t), E(t), B(t) for Each x_k in the swing up phase</h2><pre class="codeinput"><span class="comment">%From generated state trajectory, compute for the state matrix E_t, A_t,</span>
<span class="comment">%B_t, C_t, D_t wrt time for every timestep h since the system is not</span>
<span class="comment">%linearizable during the swing up case</span>

s.h=0.01; s.N=T/s.h; s.mc=10; t=[0:s.N]*s.h; <span class="comment">% STEP 0: initialize simulation</span>
s.m1=1; s.L1=1;    s.ell1=s.L1; s.I1=s.m1*s.ell1^2/3; <span class="comment">% system, &amp; derived parameters</span>
s.m2=0.5; s.L2=0.5;  s.ell2=s.L2; s.I2=s.m2*s.ell2^2/3; alpha=0.1;
s.B=[0; 0; 0; 1; 0; 0]; s.Q=diag([0 0 0 0 0 0]); s.R=0; s.QT=diag([5 40 10 .1 60 10]);
g = 9.81;

<span class="keyword">for</span> i = 1:length(x_k)
    A_temp = Compute_A(x_k(:,i) ,s); <span class="comment">%NR funtion</span>
    A_t(i) = {A_temp};
<span class="keyword">end</span>

<span class="keyword">for</span> i = 1:length(x_k)
    E_temp = Compute_E(x_k(1:6,i),s); <span class="comment">%NR funtion</span>
    E_t(i) = {E_temp};
<span class="keyword">end</span>

<span class="keyword">for</span> i = 1:length(x_k)
    B_temp = [0; 0; 0; 1; 0; 0]; <span class="comment">%NR funtion</span>
    B_t(i) = {B_temp};
<span class="keyword">end</span>

<span class="keyword">for</span> i = 1:length(x_k)
    C_temp = [[1 0 0  0   0   0];<span class="keyword">...</span><span class="comment"> %Sending x, theta1, theta2</span>
              [0 1 0  0   0   0];<span class="keyword">...</span>
              [0 0 1  0   0   0];<span class="keyword">...</span>
              [0 0 0  0   0   0];<span class="keyword">...</span>
              [0 0 0  0   0   0];<span class="keyword">...</span>
              [0 0 0  0   0   0]];
    C_t(i) = {C_temp};
<span class="keyword">end</span>
</pre><h2 id="6">Compute K(t) using A(t), E(t), B(t), C(t)</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment"> compute controller gain K(t) using differential ricatti equation (DRE),
</span><span class="comment"> which can be solved using RK4 marching. This K(t) controls the the system from
</span><span class="comment"> one timestep to another
</span><span class="comment">
</span><span class="comment">%}
</span>h = s.h; <span class="comment">%timestep</span>

R = .1; <span class="comment">%controller cost</span>
Q = [[1 0 0  0   0   0];<span class="keyword">...</span><span class="comment"> %penilize theta anlges more than other states</span>
     [0 7 0  0   0   0];<span class="keyword">...</span>
     [0 0 7  0   0   0];<span class="keyword">...</span>
     [0 0 0  1   0   0];<span class="keyword">...</span>
     [0 0 0  0   1   0];<span class="keyword">...</span>
     [0 0 0  0   0   1]];

X_t = {}; <span class="comment">%allocate cell frame to store X at every time frame</span>
X_t(length(u_k)) = {eye(6)}; <span class="comment">%X at T</span>

<span class="comment">%Backward March to find X(t)using RK4 + DRE</span>
<span class="keyword">for</span> i = length(u_k):-1:2

f1 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i},R,Q);
f2 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f1*h/2,R,Q);
f3 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f2*h/2,R,Q);
f4 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f3*h,R,Q);

X_t{i-1} = X_t{i} - h*(f1/6 + f2/3 + f3/3 + f4/6);

<span class="keyword">end</span>

<span class="comment">%find K(t) using X(t) using NR22.13a</span>
<span class="keyword">for</span> i = 1:length(u_k)
    K_t(i) = {-inv(R)*B_t{i}'*X_t{i}};
<span class="keyword">end</span>
</pre><h2 id="7">Compute L(t) using A(t), E(t), B(t), C(t)</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment"> compute observer gain L(t) using differential ricatti equation, which
</span><span class="comment"> can be solved using RK4 forward marching
</span><span class="comment">%}
</span>
Q1 = eye(6); <span class="comment">%covariance of state disturbance</span>
Q2 = eye(6); <span class="comment">%convariance of sensor noise</span>

P_t = {}; <span class="comment">%allocate space for storage of P</span>

P_t(1) = {eye(6)}; <span class="comment">%intial estimation covariance</span>

<span class="comment">%forward march to find L(t) using RK4 and DRE NR22.30</span>
<span class="keyword">for</span> i = 1:1:length(u_k)

f1 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i},R,Q);
f2 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f1*h/2,R,Q);
f3 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f2*h/2,R,Q);
f4 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f3*h,R,Q);

P_t{i+1} = P_t{i} + h*(f1/6 + f2/3 + f3/3 + f4/6);

<span class="keyword">end</span>

<span class="comment">%find L(t) using P(t) by appying NR22.30</span>
<span class="keyword">for</span> i = 1:length(u_k)
    L_t(i) = {-P_t{i}*C_t{i}'*inv(Q2)};
<span class="keyword">end</span>
</pre><h2 id="8">Uncomment this section to check eigenvalues of the control + observation system</h2><pre class="codeinput"><span class="comment">% eigControl = {};</span>
<span class="comment">% ControlSys = {};</span>
<span class="comment">% for i = 1:length(u_k)</span>
<span class="comment">%     ControlSys(i) = {inv(E_t{i})*A_t{i} + inv(E_t{i})* B_t{i}*K_t{i}};</span>
<span class="comment">%    [evecK, eigControl{i}] = eig(ControlSys{i});</span>
<span class="comment">% end</span>


<span class="comment">% eigEstimate = {};</span>
<span class="comment">% EstimateSys = {};</span>
<span class="comment">% for i = 1:length(u_k)</span>
<span class="comment">%     EstimateSys(i) = {A_t{i} + L_t{i}*C_t{i}};</span>
<span class="comment">%    [evecL, eigEstimate{i}] = eig(EstimateSys{i});</span>
<span class="comment">% end</span>
</pre><h2 id="9">Plot State Trajectory using K(t) Controller</h2><pre class="codeinput"><span class="comment">%From derivation, dx'/dt = inv(E) * [A + Bk - Bk*x_bar + Bu_bar]</span>
<span class="comment">%Note that u_k != K(t)*x_k because u_k is designed from openloop adjoint</span>
<span class="comment">%methods</span>


<span class="comment">% March protabation x_prime using RK4 and dx'/dt derivation</span>
dx_prime = {};
x_prime(:,1) = [0 0 0 0 0 0]';
<span class="keyword">for</span> i = 1:1:length(u_k)-1

    f1 = inv(E_t{i})*(A_t{i} + B_t{i})* x_prime(:,i) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f2 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f1*h/2) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f3 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f2*h/2) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f4 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f3*h) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);

    x_prime(:,i+1) = x_prime(i) + h*(f1/6 + f2/3 + f3/3 + f4/6);
<span class="keyword">end</span>

<span class="comment">% Determine state simulation by adding nominal state and the proptabation states</span>
<span class="comment">% ideally, protabation tends to zero if controller is designed properly</span>
<span class="comment">% x_sim should ideally be very close to x_k</span>
x_sim = x_k(1:6, :) + x_prime*h;


figure(2); subplot(2,1,1); plot(t,x_k(1,:),<span class="string">'r--'</span>,t,x_k(2,:),<span class="string">'b--'</span>,t,x_k(3,:),<span class="string">'g--'</span>); hold <span class="string">on</span>; title(<span class="string">"Openloop State vs Closeloop Control State"</span>)
                        legend(<span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>)
              subplot(2,1,2); plot(t,x_k(4,:),<span class="string">'r--'</span>,t,x_k(5,:),<span class="string">'b--'</span>,t,x_k(6,:),<span class="string">'g--'</span>); hold <span class="string">on</span>;
                        legend(<span class="string">"OL dx in m"</span>, <span class="string">"OL dtheta1 in rad"</span>, <span class="string">"OL dtheta2 in rad"</span>)

figure(2); subplot(2,1,1); plot(t,x_sim(1,:),<span class="string">'r'</span>,t,x_sim(2,:),<span class="string">'b'</span>,t,x_sim(3,:),<span class="string">'g'</span>);
                        legend(<span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>, <span class="string">"CL x in m"</span>, <span class="string">"CL theta1 in rad"</span>, <span class="string">"CL theta2 in rad"</span>)
                    subplot(2,1,2); plot(t,x_sim(4,:),<span class="string">'r-'</span>,t,x_sim(5,:),<span class="string">'b-'</span>,t,x_sim(6,:),<span class="string">'g-'</span>);
                        legend(<span class="string">"OL dx in m"</span>, <span class="string">"OL dtheta1 in rad"</span>, <span class="string">"OL dtheta2 in rad"</span>, <span class="string">"CL dx in m"</span>, <span class="string">"CL dtheta1 in rad"</span>, <span class="string">"CL dtheta2 in rad"</span>)


<span class="comment">%plots shows convergence of simulated close loop x and open loop x</span>
</pre><img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_02.png" alt=""> <h2 id="10">Add Estimation Technique to system using L(t)</h2><pre class="codeinput"><span class="comment">% March protabation x_prime using the following derivation</span>
<span class="comment">%{
</span><span class="comment">dx_prime = (inv(E_t)*A_t + L_t*C_t)* x_hat_prime(:,i)...
</span><span class="comment">            + (2*L_t*C_t - inv(E_t)*B_t*K_t)*x_k(1:6, i)...
</span><span class="comment">            + (L_t*C_t + inv(E_t)*B_t*K_t)*x_prime(:,i)...
</span><span class="comment">            + inv(E_t)*B_t*u_k(i);
</span><span class="comment">%}
</span>
x_hat_prime(:,1) = [0 0 0 0 0 0]';
<span class="keyword">for</span> i = 1:1:length(u_k)-1

     f1 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* x_hat_prime(:,i)<span class="keyword">...</span>
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)<span class="keyword">...</span>
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)<span class="keyword">...</span>
        + inv(E_t{i})*B_t{i}*u_k(i);

     f2 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f1*h/2) <span class="keyword">...</span>
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)<span class="keyword">...</span>
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)<span class="keyword">...</span>
        + inv(E_t{i})*B_t{i}*u_k(i);

     f3 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f2*h/2) <span class="keyword">...</span>
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)<span class="keyword">...</span>
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)<span class="keyword">...</span>
        + inv(E_t{i})*B_t{i}*u_k(i);
     f4 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f3*h) <span class="keyword">...</span>
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)<span class="keyword">...</span>
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)<span class="keyword">...</span>
        + inv(E_t{i})*B_t{i}*u_k(i);

    x_hat_prime(:,i+1) = x_hat_prime(i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

<span class="keyword">end</span>

x_estimation_sim = x_k(1:6, :) + x_hat_prime*h;

figure(3); subplot(2,1,1); plot(t,x_k(1,:),<span class="string">'r--'</span>,t,x_k(2,:),<span class="string">'b--'</span>,t,x_k(3,:),<span class="string">'g--'</span>); hold <span class="string">on</span>; title(<span class="string">"Openloop State vs Control+Estimation State"</span>)
                        legend(<span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>)
                        xlabel(<span class="string">"time in 0.01sec"</span>)
              subplot(2,1,2); plot(t,x_k(4,:),<span class="string">'r--'</span>,t,x_k(5,:),<span class="string">'b--'</span>,t,x_k(6,:),<span class="string">'g--'</span>); hold <span class="string">on</span>;
                        legend(<span class="string">"OL dx in m"</span>, <span class="string">"OL dtheta1 in rad"</span>, <span class="string">"OL dtheta2 in rad"</span>, <span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>)
                        xlabel(<span class="string">"time in 0.01sec"</span>)


figure(3); subplot(2,1,1); plot(t,x_estimation_sim (1,:),<span class="string">'r'</span>,t,x_estimation_sim (2,:),<span class="string">'b'</span>,t,x_estimation_sim (3,:),<span class="string">'g'</span>);
                legend(<span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>, <span class="string">"FS x in m"</span>, <span class="string">"FS theta1 in rad"</span>, <span class="string">"FS theta2 in rad"</span>)
                xlabel(<span class="string">"time in 0.01sec"</span>)
            subplot(2,1,2); plot(t,x_estimation_sim (4,:),<span class="string">'r'</span>,t,x_estimation_sim (5,:),<span class="string">'b'</span>,t,x_estimation_sim (6,:),<span class="string">'g'</span>);
                legend(<span class="string">"OL x in m"</span>, <span class="string">"OL theta1 in rad"</span>, <span class="string">"OL theta2 in rad"</span>, <span class="string">"FS x in m"</span>, <span class="string">"FS theta1 in rad"</span>, <span class="string">"FS theta2 in rad"</span>)
                xlabel(<span class="string">"time in 0.01sec"</span>)
</pre><pre class="codeoutput">Warning: Ignoring extra legend entries. 
</pre><img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_03.png" alt=""> <img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_04.png" alt=""> <h2 id="11">Part LTI Component of Control Problem</h2><pre class="codeinput"><span class="comment">%{once states are near zero and can be linearizable, we can find a</span>
<span class="comment">%constant K and L using algebraic riccatti by calling on icare</span>

<span class="comment">%compute state matrix when linearized about [0 0 0 0 0 0]</span>

E44 = s.m1 + s.m2 + s.mc; E45 = -s.m1*s.L1; E46 = -s.m2*s.L2;
E54 = -s.m1*s.L1 ; E55 = s.I1 + s.m1*s.L1^2;
E64 = -s.m2*s.L2 ; E66 = s.I2 + s.m2*s.L2^2;


E_bar = [[1 0 0  0   0   0];<span class="keyword">...</span>
     [0 1 0  0   0   0];
     [0 0 1  0   0   0];
     [0 0 0 E44 E45 E46];
     [0 0 0 E54 E55  0 ];
     [0 0 0 E64  0  E66]];

A52 = s.m1*g*s.L1;
A63 = s.m2*g*s.L2;
A_bar = [[0  0  0  1   0   0];<span class="keyword">...</span>
         [0  0  0  0   1   0];
         [0  0  0  0   0   1];
         [0  0  0  0   0   0];
         [0 A52 0 0   0   0];
         [0  0  A63  0   0   0]];

B_bar = [0 0 0  1  0  0]';


<span class="comment">%Compute classical A, B, and C states matrix</span>

A = E_bar^-1 * A_bar;
B = E_bar^-1 * B_bar;
C = [[1 0 0  0   0   0];<span class="keyword">...</span>
     [0 1 0  0   0   0];<span class="keyword">...</span>
     [0 0 1  0   0   0];<span class="keyword">...</span>
     [0 0 0  0   0   0];<span class="keyword">...</span>
     [0 0 0  0   0   0];<span class="keyword">...</span>
     [0 0 0  0   0   0]];<span class="keyword">...</span>


D = [0 0 0 0 0 0]';

E = eye(6);
</pre><h2 id="12">Solve for LTI Controller Gain K and Observer Gain L</h2><pre class="codeinput"><span class="comment">% Solve algebraic raccatti K</span>
Q = diag([1.2 1 1 1 80 80]);
R = 3;
[X,K_inf, nouseeig] = icare(A,B,Q,R);
<span class="comment">%note, the K here is negative of the one from the notaion of NR22</span>


<span class="comment">% Solve for raccatti L using iCARE (use a-bk)</span>
Q1 = eye(6);
Q2 = eye(6);
[P, L_inf, ect] = icare(A', C', Q1, Q2) ;


<span class="comment">%note, the L here is negative of the one from the notaion of NR22</span>
</pre><h2 id="13">March States Starting from time T on the Estimated Simulated LQR States using RK4</h2><pre class="codeinput">T_inf = 40;
<span class="keyword">for</span> i = 301:1:T_inf/h

    f1 = (A-B*K_inf)*x_sim(:,i);
    f2 = (A-B*K_inf)*(x_sim(:,i) + f1*h/2) ;
    f3 = (A-B*K_inf)*(x_sim(:,i) + f2*h/2) ;
    f4 = (A-B*K_inf)*(x_sim(:,i) + f3*h) ;
    x_sim(:,i+1) = x_sim(:,i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

<span class="keyword">end</span>

t_inf = 0:T_inf/h;
figure(4); subplot(2,1,1); plot(t_inf,x_sim(1,:),<span class="string">'r'</span>,t_inf,x_sim(2,:),<span class="string">'b'</span>,t_inf,x_sim(3,:),<span class="string">'g'</span>); title(<span class="string">"LTV + LTI Controlled States LQR"</span>)
                legend(<span class="string">"x in m"</span>, <span class="string">"theta1 in rad"</span>, <span class="string">"theta2 in rad"</span>); xlabel(<span class="string">"time in 0.01sec"</span>)
            subplot(2,1,2); plot(t_inf,x_sim(4,:),<span class="string">'r'</span>,t_inf,x_sim(5,:),<span class="string">'b'</span>,t_inf,x_sim(6,:),<span class="string">'g'</span>);
                legend(<span class="string">"x in m"</span>, <span class="string">"theta1 in rad"</span>, <span class="string">"theta2 in rad"</span>);xlabel(<span class="string">"time in 0.01sec"</span>)
</pre><img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_05.png" alt=""> <h2 id="14">March States Starting from time T on the Estimated LQG States using RK4</h2><pre class="codeinput"><span class="keyword">for</span> i = 301:1:T_inf/h

    f1 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f2 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f3 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f4 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);

    x_estimation_sim(:,i+1) = x_estimation_sim(:,i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

<span class="keyword">end</span>

figure(5); subplot(2,1,1); plot(t_inf,x_estimation_sim(1,:),<span class="string">'r'</span>,t_inf,x_estimation_sim(2,:),<span class="string">'b'</span>,t_inf,x_estimation_sim(3,:),<span class="string">'g'</span>); title(<span class="string">"LTV + LTI Controlled + Obserber States (LQG)"</span>)
                    legend(<span class="string">"x in m"</span>, <span class="string">"theta1 in rad"</span>, <span class="string">"theta2 in rad"</span>); xlabel(<span class="string">"time in 0.01sec"</span>);
                    subplot(2,1,2); plot(t_inf,x_estimation_sim(4,:),<span class="string">'r'</span>,t_inf,x_estimation_sim(5,:),<span class="string">'b'</span>,t_inf,x_estimation_sim(6,:),<span class="string">'g'</span>);
                    legend(<span class="string">"x in m"</span>, <span class="string">"theta1 in rad"</span>, <span class="string">"theta2 in rad"</span>); xlabel(<span class="string">"time in 0.01sec"</span>);
</pre><img vspace="5" hspace="5" src="Optimal_Controller_Double_Pendulem_on_Cart_06.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%{
The following code is used to design an optimal controller and estimator for 2 pendulem of
different length and mass on a single cart. The only acutator on this car
the motor that drives the linear position of the cart. 

We are attempting to swing up both the pendulem from the inital position of
all pendulem down to both pendulem up and stabilize

%}

%% Determine u_k and state
clear all; clc; close all
load_prev = 1; %set to 1 if a previous trajectory has been generated

%{
Use code provided in NR Ch21 to generate x_k state, u_k, using adjoint
method for the swing up phase. This phase last about T = 3 seconds because 

0) Within this code, tune QT to drive error at T close to zero
1) Warm start: use an inital guess of u_k being all zeros
2) iterate the provided function with a new u_k until the state reach near
desired value of [0 0 0 0 0 0]
3)save x_k and u_k

%}

%% Uncomment the Following Code if you need an x_k and u_k using Adjoint method to generate swingup states trajectory

% T = 3; %approx sqrt(g/l) 
% 
% %initial guess of u_k being all zero 
% [u_k(:,1),x_k] = OptimizeTraj(T);
% 
% state_at_T(:,1) = x_k(1:6, end);
% 
% number_of_trial = 1;
% trial_number = 1:number_of_trial
% for i = trial_number
%     [u_k(:,i+1), x_k] = OptimizeTraj(T, u_k(:,i))
%     state_at_T(:,i+1) = x_k(1:6, end)
% end

%% If Previous Trajectory has been generated, run this code

%Trjectory can be manually optimzed by tuning Q iteration by interation by
%using the file "AdjointPathManualIteration.m"

%load previous trajectory is better

if load_prev == 1 
    clear all; clc;
    load("SavePoint3.mat")
    figure(1); clf; subplot(3,1,1); plot(t,x_k(1,:),'r-',t,x_k(2,:),'b-',t,x_k(3,:),'g-'); hold on; title("Openloop State");
              subplot(3,1,2); plot(t,x_k(4,:),'r-',t,x_k(5,:),'b-',t,x_k(6,:),'g-'); hold on;
              subplot(3,1,3); plot(t,u_k,'rREPLACE_WITH_DASH_DASH'); hold on;
              
end



%% Find A(t), E(t), B(t) for Each x_k in the swing up phase

%From generated state trajectory, compute for the state matrix E_t, A_t,
%B_t, C_t, D_t wrt time for every timestep h since the system is not
%linearizable during the swing up case

s.h=0.01; s.N=T/s.h; s.mc=10; t=[0:s.N]*s.h; % STEP 0: initialize simulation
s.m1=1; s.L1=1;    s.ell1=s.L1; s.I1=s.m1*s.ell1^2/3; % system, & derived parameters
s.m2=0.5; s.L2=0.5;  s.ell2=s.L2; s.I2=s.m2*s.ell2^2/3; alpha=0.1;
s.B=[0; 0; 0; 1; 0; 0]; s.Q=diag([0 0 0 0 0 0]); s.R=0; s.QT=diag([5 40 10 .1 60 10]);
g = 9.81;

for i = 1:length(x_k)
    A_temp = Compute_A(x_k(:,i) ,s); %NR funtion
    A_t(i) = {A_temp};
end

for i = 1:length(x_k)
    E_temp = Compute_E(x_k(1:6,i),s); %NR funtion
    E_t(i) = {E_temp};
end

for i = 1:length(x_k)
    B_temp = [0; 0; 0; 1; 0; 0]; %NR funtion
    B_t(i) = {B_temp};
end

for i = 1:length(x_k)
    C_temp = [[1 0 0  0   0   0];... %Sending x, theta1, theta2
              [0 1 0  0   0   0];...
              [0 0 1  0   0   0];...
              [0 0 0  0   0   0];...
              [0 0 0  0   0   0];...
              [0 0 0  0   0   0]];
    C_t(i) = {C_temp};
end

%% Compute K(t) using A(t), E(t), B(t), C(t)

%{
 compute controller gain K(t) using differential ricatti equation (DRE),
 which can be solved using RK4 marching. This K(t) controls the the system from
 one timestep to another

%}
h = s.h; %timestep

R = .1; %controller cost
Q = [[1 0 0  0   0   0];... %penilize theta anlges more than other states
     [0 7 0  0   0   0];...
     [0 0 7  0   0   0];...
     [0 0 0  1   0   0];...
     [0 0 0  0   1   0];... 
     [0 0 0  0   0   1]];

X_t = {}; %allocate cell frame to store X at every time frame
X_t(length(u_k)) = {eye(6)}; %X at T

%Backward March to find X(t)using RK4 + DRE
for i = length(u_k):-1:2

f1 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i},R,Q);
f2 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f1*h/2,R,Q);
f3 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f2*h/2,R,Q);
f4 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} - f3*h,R,Q);

X_t{i-1} = X_t{i} - h*(f1/6 + f2/3 + f3/3 + f4/6);

end

%find K(t) using X(t) using NR22.13a
for i = 1:length(u_k)
    K_t(i) = {-inv(R)*B_t{i}'*X_t{i}};
end

%% Compute L(t) using A(t), E(t), B(t), C(t)

%{
 compute observer gain L(t) using differential ricatti equation, which
 can be solved using RK4 forward marching
%}

Q1 = eye(6); %covariance of state disturbance
Q2 = eye(6); %convariance of sensor noise 

P_t = {}; %allocate space for storage of P

P_t(1) = {eye(6)}; %intial estimation covariance

%forward march to find L(t) using RK4 and DRE NR22.30
for i = 1:1:length(u_k)

f1 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i},R,Q);
f2 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f1*h/2,R,Q);
f3 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f2*h/2,R,Q);
f4 = KRiccati(E_t{i},A_t{i},B_t{i},X_t{i} + f3*h,R,Q);

P_t{i+1} = P_t{i} + h*(f1/6 + f2/3 + f3/3 + f4/6);

end

%find L(t) using P(t) by appying NR22.30
for i = 1:length(u_k)
    L_t(i) = {-P_t{i}*C_t{i}'*inv(Q2)};
end

%% Uncomment this section to check eigenvalues of the control + observation system

% eigControl = {};
% ControlSys = {};
% for i = 1:length(u_k)
%     ControlSys(i) = {inv(E_t{i})*A_t{i} + inv(E_t{i})* B_t{i}*K_t{i}};
%    [evecK, eigControl{i}] = eig(ControlSys{i});
% end


% eigEstimate = {};
% EstimateSys = {};
% for i = 1:length(u_k)
%     EstimateSys(i) = {A_t{i} + L_t{i}*C_t{i}};
%    [evecL, eigEstimate{i}] = eig(EstimateSys{i});
% end

%% Plot State Trajectory using K(t) Controller

%From derivation, dx'/dt = inv(E) * [A + Bk - Bk*x_bar + Bu_bar]
%Note that u_k != K(t)*x_k because u_k is designed from openloop adjoint
%methods


% March protabation x_prime using RK4 and dx'/dt derivation
dx_prime = {};
x_prime(:,1) = [0 0 0 0 0 0]';
for i = 1:1:length(u_k)-1

    f1 = inv(E_t{i})*(A_t{i} + B_t{i})* x_prime(:,i) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f2 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f1*h/2) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f3 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f2*h/2) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);
    f4 = inv(E_t{i})*(A_t{i} + B_t{i})* (x_prime(:,i) + f3*h) - inv(E_t{i})*B_t{i}*K_t{i}*x_k(1:6,i) + inv(E_t{i})*B_t{i}*u_k(i);  
    
    x_prime(:,i+1) = x_prime(i) + h*(f1/6 + f2/3 + f3/3 + f4/6);
end

% Determine state simulation by adding nominal state and the proptabation states
% ideally, protabation tends to zero if controller is designed properly
% x_sim should ideally be very close to x_k
x_sim = x_k(1:6, :) + x_prime*h;


figure(2); subplot(2,1,1); plot(t,x_k(1,:),'rREPLACE_WITH_DASH_DASH',t,x_k(2,:),'bREPLACE_WITH_DASH_DASH',t,x_k(3,:),'gREPLACE_WITH_DASH_DASH'); hold on; title("Openloop State vs Closeloop Control State")
                        legend("OL x in m", "OL theta1 in rad", "OL theta2 in rad")
              subplot(2,1,2); plot(t,x_k(4,:),'rREPLACE_WITH_DASH_DASH',t,x_k(5,:),'bREPLACE_WITH_DASH_DASH',t,x_k(6,:),'gREPLACE_WITH_DASH_DASH'); hold on;
                        legend("OL dx in m", "OL dtheta1 in rad", "OL dtheta2 in rad")

figure(2); subplot(2,1,1); plot(t,x_sim(1,:),'r',t,x_sim(2,:),'b',t,x_sim(3,:),'g');
                        legend("OL x in m", "OL theta1 in rad", "OL theta2 in rad", "CL x in m", "CL theta1 in rad", "CL theta2 in rad")
                    subplot(2,1,2); plot(t,x_sim(4,:),'r-',t,x_sim(5,:),'b-',t,x_sim(6,:),'g-');
                        legend("OL dx in m", "OL dtheta1 in rad", "OL dtheta2 in rad", "CL dx in m", "CL dtheta1 in rad", "CL dtheta2 in rad")


%plots shows convergence of simulated close loop x and open loop x


%% Add Estimation Technique to system using L(t)

% March protabation x_prime using the following derivation
%{
dx_prime = (inv(E_t)*A_t + L_t*C_t)* x_hat_prime(:,i)...
            + (2*L_t*C_t - inv(E_t)*B_t*K_t)*x_k(1:6, i)...
            + (L_t*C_t + inv(E_t)*B_t*K_t)*x_prime(:,i)...
            + inv(E_t)*B_t*u_k(i);
%}

x_hat_prime(:,1) = [0 0 0 0 0 0]';
for i = 1:1:length(u_k)-1
    
     f1 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* x_hat_prime(:,i)...
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)...
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)...
        + inv(E_t{i})*B_t{i}*u_k(i);

     f2 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f1*h/2) ...
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)...
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)...
        + inv(E_t{i})*B_t{i}*u_k(i);

     f3 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f2*h/2) ...
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)...
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)...
        + inv(E_t{i})*B_t{i}*u_k(i);
     f4 = (inv(E_t{i})*A_t{i} + L_t{i}*C_t{i})* (x_hat_prime(:,i) + f3*h) ...
        + (2*L_t{i}*C_t{i} - inv(E_t{i})*B_t{i}*K_t{i})*x_k(1:6, i)...
        + (L_t{i}*C_t{i} + inv(E_t{i})*B_t{i}*K_t{i})*x_prime(:,i)...
        + inv(E_t{i})*B_t{i}*u_k(i);

    x_hat_prime(:,i+1) = x_hat_prime(i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

end

x_estimation_sim = x_k(1:6, :) + x_hat_prime*h;

figure(3); subplot(2,1,1); plot(t,x_k(1,:),'rREPLACE_WITH_DASH_DASH',t,x_k(2,:),'bREPLACE_WITH_DASH_DASH',t,x_k(3,:),'gREPLACE_WITH_DASH_DASH'); hold on; title("Openloop State vs Control+Estimation State")
                        legend("OL x in m", "OL theta1 in rad", "OL theta2 in rad")
                        xlabel("time in 0.01sec")
              subplot(2,1,2); plot(t,x_k(4,:),'rREPLACE_WITH_DASH_DASH',t,x_k(5,:),'bREPLACE_WITH_DASH_DASH',t,x_k(6,:),'gREPLACE_WITH_DASH_DASH'); hold on; 
                        legend("OL dx in m", "OL dtheta1 in rad", "OL dtheta2 in rad", "OL x in m", "OL theta1 in rad", "OL theta2 in rad")
                        xlabel("time in 0.01sec")


figure(3); subplot(2,1,1); plot(t,x_estimation_sim (1,:),'r',t,x_estimation_sim (2,:),'b',t,x_estimation_sim (3,:),'g');
                legend("OL x in m", "OL theta1 in rad", "OL theta2 in rad", "FS x in m", "FS theta1 in rad", "FS theta2 in rad")     
                xlabel("time in 0.01sec")
            subplot(2,1,2); plot(t,x_estimation_sim (4,:),'r',t,x_estimation_sim (5,:),'b',t,x_estimation_sim (6,:),'g');
                legend("OL x in m", "OL theta1 in rad", "OL theta2 in rad", "FS x in m", "FS theta1 in rad", "FS theta2 in rad")     
                xlabel("time in 0.01sec")
                            


%% Part LTI Component of Control Problem

%{once states are near zero and can be linearizable, we can find a
%constant K and L using algebraic riccatti by calling on icare

%compute state matrix when linearized about [0 0 0 0 0 0]

E44 = s.m1 + s.m2 + s.mc; E45 = -s.m1*s.L1; E46 = -s.m2*s.L2;
E54 = -s.m1*s.L1 ; E55 = s.I1 + s.m1*s.L1^2;
E64 = -s.m2*s.L2 ; E66 = s.I2 + s.m2*s.L2^2;


E_bar = [[1 0 0  0   0   0];...
     [0 1 0  0   0   0];
     [0 0 1  0   0   0];
     [0 0 0 E44 E45 E46];
     [0 0 0 E54 E55  0 ];
     [0 0 0 E64  0  E66]];

A52 = s.m1*g*s.L1;
A63 = s.m2*g*s.L2;
A_bar = [[0  0  0  1   0   0];...
         [0  0  0  0   1   0];
         [0  0  0  0   0   1];
         [0  0  0  0   0   0];
         [0 A52 0 0   0   0];
         [0  0  A63  0   0   0]];

B_bar = [0 0 0  1  0  0]';


%Compute classical A, B, and C states matrix

A = E_bar^-1 * A_bar;
B = E_bar^-1 * B_bar;
C = [[1 0 0  0   0   0];...
     [0 1 0  0   0   0];...
     [0 0 1  0   0   0];...
     [0 0 0  0   0   0];...
     [0 0 0  0   0   0];...
     [0 0 0  0   0   0]];...


D = [0 0 0 0 0 0]';

E = eye(6);

%% Solve for LTI Controller Gain K and Observer Gain L
 
% Solve algebraic raccatti K
Q = diag([1.2 1 1 1 80 80]);
R = 3;
[X,K_inf, nouseeig] = icare(A,B,Q,R);
%note, the K here is negative of the one from the notaion of NR22


% Solve for raccatti L using iCARE (use a-bk)
Q1 = eye(6);
Q2 = eye(6);
[P, L_inf, ect] = icare(A', C', Q1, Q2) ;


%note, the L here is negative of the one from the notaion of NR22

%% March States Starting from time T on the Estimated Simulated LQR States using RK4


T_inf = 40;
for i = 301:1:T_inf/h

    f1 = (A-B*K_inf)*x_sim(:,i);    
    f2 = (A-B*K_inf)*(x_sim(:,i) + f1*h/2) ;
    f3 = (A-B*K_inf)*(x_sim(:,i) + f2*h/2) ;
    f4 = (A-B*K_inf)*(x_sim(:,i) + f3*h) ;
    x_sim(:,i+1) = x_sim(:,i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

end

t_inf = 0:T_inf/h;
figure(4); subplot(2,1,1); plot(t_inf,x_sim(1,:),'r',t_inf,x_sim(2,:),'b',t_inf,x_sim(3,:),'g'); title("LTV + LTI Controlled States LQR")
                legend("x in m", "theta1 in rad", "theta2 in rad"); xlabel("time in 0.01sec")
            subplot(2,1,2); plot(t_inf,x_sim(4,:),'r',t_inf,x_sim(5,:),'b',t_inf,x_sim(6,:),'g');
                legend("x in m", "theta1 in rad", "theta2 in rad");xlabel("time in 0.01sec")


%% March States Starting from time T on the Estimated LQG States using RK4

for i = 301:1:T_inf/h

    f1 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f2 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f3 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    f4 = (A-L_inf'*C)*x_estimation_sim(:,i) - B*K_inf*x_estimation_sim(:,i) + L_inf'*C*x_sim(:,i);
    
    x_estimation_sim(:,i+1) = x_estimation_sim(:,i) + h*(f1/6 + f2/3 + f3/3 + f4/6);

end

figure(5); subplot(2,1,1); plot(t_inf,x_estimation_sim(1,:),'r',t_inf,x_estimation_sim(2,:),'b',t_inf,x_estimation_sim(3,:),'g'); title("LTV + LTI Controlled + Obserber States (LQG)")
                    legend("x in m", "theta1 in rad", "theta2 in rad"); xlabel("time in 0.01sec");
                    subplot(2,1,2); plot(t_inf,x_estimation_sim(4,:),'r',t_inf,x_estimation_sim(5,:),'b',t_inf,x_estimation_sim(6,:),'g');
                    legend("x in m", "theta1 in rad", "theta2 in rad"); xlabel("time in 0.01sec");


##### SOURCE END #####
--></body></html>